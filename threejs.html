<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <!-- <script src="js/OrbitalsControl.js"></script> -->

		<script>

            /////////////////// SQUARE ANIMATION /////////////////////////

			// const scene = new THREE.Scene();
			// const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			// const renderer = new THREE.WebGLRenderer();
			// renderer.setSize( window.innerWidth, window.innerHeight );
			// document.body.appendChild( renderer.domElement );

			// const geometry = new THREE.BoxGeometry();
			// const material = new THREE.MeshBasicMaterial( { color: 0xf18c41 } );
			// const cube = new THREE.Mesh( geometry, material );
			// scene.add( cube );

			// camera.position.z = 5;

			// const animate = function () {
			// 	requestAnimationFrame( animate );

			// 	cube.rotation.x += 0.01;
			// 	cube.rotation.y += 0.01;

			// 	renderer.render( scene, camera );
			// };

			// animate();

            ///////////////////////////////////////////////////////////////

            
            
            
            
            ////////////////////////// ARROW ///////////////////////////////////            
            
            // const renderer = new THREE.WebGLRenderer();
            // renderer.setSize( window.innerWidth, window.innerHeight );
            // document.body.appendChild( renderer.domElement );

            // const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
            // camera.position.set( 0, 0, 100 );
            // camera.lookAt( 0, 0, 0 );

            // const scene = new THREE.Scene();

            // //create a blue LineBasicMaterial
            // const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );

            // const points = [];
            // points.push( new THREE.Vector3( - 10, 0, 0 ) );
            // points.push( new THREE.Vector3( 0, 10, 0 ) );
            // points.push( new THREE.Vector3( 10, 0, 0 ) );

            // const geometry = new THREE.BufferGeometry().setFromPoints( points );

            // const line = new THREE.Line( geometry, material );
            
            // scene.add( line );
            // renderer.render( scene, camera );

            ///////////////////////////////////////////////////////////////
            
            
            
            ////////////////////// VERTICES ORBITAL //////////////////////
            
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement )

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            const controls = new OrbitControls( camera, renderer.domElement );
            // const controls = new THREE.OrbitControls();


            //controls.update() must be called after any manual changes to the camera's transform
            camera.position.set( 0, 20, 100 );
            controls.update();

            const vertices = [];

            for ( let i = 0; i < 10000; i ++ ) 
            {
                const x = THREE.MathUtils.randFloatSpread( 2000 );
                const y = THREE.MathUtils.randFloatSpread( 2000 );
                const z = THREE.MathUtils.randFloatSpread( 2000 );

                vertices.push( x, y, z );
                
                var myObj = { x : x, y : y, z : z };
                console.log(myObj);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

            const material = new THREE.PointsMaterial( { color: 0xf18c41 } );

            const points = new THREE.Points( geometry, material );

            scene.add( points );

            function animate() 
            {
                requestAnimationFrame( animate );

                // required if controls.enableDamping or controls.autoRotate are set to true
                controls.update();

                renderer.render( scene, camera );
            }

            animate();

            ///////////////////////////////////////////////////////////////

		</script>
	</body>
</html>